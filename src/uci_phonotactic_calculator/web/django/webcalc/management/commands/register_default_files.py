"""
Django management command to register default dataset files in the database.
This allows them to be displayed in the web interface.
"""

import os
from os.path import isfile, join
from typing import Any
from argparse import ArgumentParser

from django.core.management.base import BaseCommand
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage

from uci_phonotactic_calculator.web.django import settings
from uci_phonotactic_calculator.web.django.webcalc.models import DefaultFile


class Command(BaseCommand):
    """Register default dataset files in the database."""

    help = "Register default dataset files in the database"

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument(
            "--force",
            action="store_true",
            help="Force re-registration of files even if they already exist",
        )

    def handle(self, *args: Any, **options: Any) -> None:
        force = options.get("force", False)

        # File descriptions
        file_descriptions = {
            "english.csv": "A subset of the CMU Pronouncing Dictionary with CELEX frequencies > 1. This is notated in ARPABET. Numbers indicating vowel stress have been removed.",
            "english_freq.csv": "A subset of the CMU Pronouncing Dictionary with CELEX frequencies. This data is represented in ARPABET.",
            "english_needle.csv": "Data set from Needle et al. (2022). Consists of about 11,000 monomorphemic words from CELEX (Baayen et al. 1995) in ARPABET transcription.",
            "english_onsets.csv": "55 English onsets and their CELEX type frequencies in ARPABET format from Hayes & Wilson (2008). A subset of the onsets in the CMU Pronouncing Dictionary.",
            "finnish.csv": "From a word list generated by the Institute for the Languages of Finland (http://kaino.kotus.fi/sanat/nykysuomi/). Represented orthographically. See Mayer (2020) for details.",
            "french.csv": "French corpus used in Goldsmith & Xanthos (2009) and Mayer (2020). Represented in IPA.",
            "polish_onsets.csv": "Polish onsets with type frequencies from Jarosz (2017). Generated from a corpus of child-directed speech consisting of about 43,000 word types (Haman et al. 2011). Represented orthographically.",
            "samoan.csv": "Samoan word list from Milner (1993), compiled by Kie Zuraw. Represented in IPA.",
            "spanish_stress.csv": "A set of about 24,000 word types including inflected forms from the EsPal database (Duchon et al. 2013) in IPA with stress encoded. Frequencies from a large collection of Spanish subtitle data.",
            "turkish.csv": "A set of about 18,000 citation forms from the Turkish Electronic Living Lexicon database (TELL; Inkelas et al. 2000) in IPA.",
        }

        # Short descriptions for dropdown menu
        short_descriptions = {
            "english.csv": "English ARPABET",
            "english_freq.csv": "English ARPABET Frequencies",
            "english_needle.csv": "English ARPABET Needle",
            "english_onsets.csv": "English Onsets ARPABET",
            "finnish.csv": "Finnish Ortho",
            "french.csv": "French IPA",
            "polish_onsets.csv": "Polish Onsets IPA",
            "samoan.csv": "Samoan IPA",
            "spanish_stress.csv": "Spanish IPA Stress",
            "turkish.csv": "Turkish IPA",
        }

        # Count how many files we need to process
        media_path = settings.MEDIA_ROOT
        default_dir = join(media_path, "default")

        if not os.path.exists(default_dir):
            self.stdout.write(
                self.style.ERROR(f"Default directory does not exist: {default_dir}")
            )
            return

        files = [f for f in os.listdir(default_dir) if isfile(join(default_dir, f))]

        if not files:
            self.stdout.write(self.style.ERROR("No files found in default directory"))
            return

        # Clear existing files if force option is used
        if force:
            DefaultFile.objects.all().delete()
            self.stdout.write(self.style.SUCCESS("Cleared existing default files"))

        # Count existing files
        existing_files = set(df.file_name for df in DefaultFile.objects.all())

        # Register each file
        registered = 0
        for file_name in files:
            if file_name in existing_files and not force:
                self.stdout.write(f"File {file_name} already registered, skipping")
                continue

            description = file_descriptions.get(file_name, "")
            short_desc = short_descriptions.get(file_name, "")

            # Create the DefaultFile object with a reference to the file
            default_file = DefaultFile(
                description=description,
                short_desc=short_desc,
            )

            # Save the file field with the path
            file_path = f"default/{file_name}"
            default_file.training_file.name = file_path
            default_file.save()

            registered += 1
            self.stdout.write(self.style.SUCCESS(f"Registered {file_name}"))

        self.stdout.write(self.style.SUCCESS(f"Registered {registered} new files"))
